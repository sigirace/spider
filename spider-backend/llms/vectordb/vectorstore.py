import os
from datetime import datetime

from langchain_milvus.vectorstores import Milvus
from pymilvus import connections, utility, Collection
from langchain_core.documents import Document
from schemas.models import MilvusSettings
from llms.vectordb.document_utils import split_docs
from tqdm import tqdm
from langchain_core.vectorstores.base import VectorStoreRetriever
from langchain_openai.embeddings import OpenAIEmbeddings

import logging

logger = logging.getLogger(__name__)


class VectorDB:
    def __init__(
        self,
        settings: MilvusSettings,
        embedding: OpenAIEmbeddings,
        alias: str = "default",
    ) -> None:
        """
        Milvus Setting config
        """
        self.settings = settings
        self.embedding = embedding
        self.alias = alias
        self._connect_to_milvus()

    def _connect_to_milvus(self):
        """
        create Milvus connection
        """
        print(f"[ {datetime.now()} ] : connect_to_milvus()")
        connections.connect(
            alias=self.alias,
            host=self.settings.milvus_host,
            port=self.settings.milvus_port,
        )

    def _disconnect_from_milvus(self):
        """
        disconnect Milvus
        """
        print(f"[ {datetime.now()} ] : disconnect_from_milvus()")
        connections.disconnect(alias=self.alias)

    def _get_vectorstore(self, collection_name: str) -> Milvus:
        """
        get vectorstore
        """
        try:
            print(f"[ {datetime.now()} ] : get_vectorstore()")

            vectorstore = Milvus(
                embedding_function=self.embedding,
                connection_args={
                    "host": self.settings.milvus_host,
                    "port": self.settings.milvus_port,
                },
                collection_name=collection_name,
            )
            return vectorstore
        except Exception as e:
            raise Exception(f"get_vectorstore failed: {e}")

    def _get_collection(self, collection_name: str) -> Collection:
        """
        get collection
        """
        try:
            print(f"[ {datetime.now()} ] : get_collection()")
            collection = Collection(collection_name)
            return collection
        except Exception as e:
            raise Exception(f"get_collection failed: {e}")

    def _drop_vectorstore(self, collection_name: str) -> None:
        """
        drop collection
        """
        try:
            print(f"[ {datetime.now()} ] : drop_vectorstore()")
            if utility.has_collection(collection_name):
                utility.drop_collection(collection_name)
                print(
                    f"[ {datetime.now()} ] : Milvus collection '{collection_name}' dropped."
                )
        except Exception as e:
            raise Exception(f"drop_vectorstore failed: {e}")

    def _exists(self, collection_name: str) -> bool:
        """
        check collection
        """
        try:
            print(f"[ {datetime.now()} ] : check_collection_exists()")
            exists = utility.has_collection(collection_name)
            return exists
        except Exception as e:
            raise Exception(f"check_collection_exists failed: {e}")

    def _get_filtered_docs(
        self, collection_name: str, docs: list[Document]
    ) -> list[Document]:
        """
        Check if the vector database already has data to minimize embedding

        The criteria to check is the key value of the document generated by DocPreproc
        """
        print(f"[ {datetime.now()} ] : get_filtered_docs()")
        if not self._exists(collection_name):
            return docs

        collection = self._get_collection(collection_name=collection_name)

        filtered_docs = []

        # Milvus에 연결

        for doc in tqdm(docs):
            key = doc.metadata.get("key")
            query = f"key == '{key}'"
            existing_docs = collection.query(expr=query)

            if not existing_docs:
                filtered_docs.append(doc)

        return filtered_docs

    def get_retriever(self, collection_name: str) -> VectorStoreRetriever:
        """
        get retriever
        """

        vectorstore = self._get_vectorstore(collection_name=collection_name)
        retriever = vectorstore.as_retriever()

        return retriever

    def core_embedding(self, collection_name: str, file_path: str) -> bool:
        """
        After embedding the chunk through Openai embedding, it is stored in a collection of vector databases
        """
        try:
            print(f"[ {datetime.now()} ] : core_embedding()")
            docs = split_docs(file_path=file_path, chunk_size=200, chunk_overlap=30)

            filtered_docs = self._get_filtered_docs(collection_name, docs)

            if not filtered_docs:
                print(f"[ {datetime.now()} ] : No new documents to embed.")
                return True

            vectorstore = Milvus.from_documents(
                documents=filtered_docs,
                embedding=self.embedding,
                collection_name=collection_name,
                connection_args={
                    "host": self.settings.milvus_host,
                    "port": self.settings.milvus_port,
                },
            )
            print(
                f"[ {datetime.now()} ] : Milvus collection '{vectorstore.collection_name}' updated."
            )

            return True
        except Exception as e:
            raise Exception(f"core_embedding failed: {e}")
